//#include<iostream>
//using namespace std;
//
//const int N = 1e5 + 10;
//
//int n, m;
//int h[N], cnt;
//
//// -----------------------------模板开始--------------------
//// 这个模板的作用是父节点和其两个孩子节点的最小值，再交换父节点和这个最小值
//void down(int u) {
//    int t = u;
//    if (u * 2 <= cnt && h[u * 2] < h[t]) t = u * 2;
//    if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
//    if (u != t) {
//        swap(h[u], h[t]);
//        down(t); // 递归处理这个输入的值，直到它down到不能down为止，即整棵树又变成了一个小根堆
//    }
//}
//// -----------------------------模板结束--------------------
//
//int main() {
//    scanf("%d%d", &n, &m);
//    for (int i = 1; i <= n; i++) scanf("%d", &h[i]); // h[]来存输入的n个节点，注意，节点的下标要从1开始
//
//    cnt = n;
//    /*
//        cnt来存节点的最大下标,因为找左右孩子需要用2*u和2*u+1，
//        为了防止边界值问题，需要判断2*u < n,2*u+1<n;
//        并且，cnt也可以看成指向堆尾的一个指针。
//    */
//
//    // 用down函数将整棵树调整为一个小根堆
//    for (int i = n / 2; i; i--) down(i); // 从2分之n开始down，建堆，时间复杂度为O(n)
//
//
//    while (m--) {
//        printf("%d ", h[1]); // 输出堆顶的数，即为当前数列的最小值
//        h[1] = h[cnt--];  // 将堆最后一个数放到堆顶，cnt--使得在逻辑上删除这个数
//        down(1); // 再将堆顶down下去，使得整棵树又变成了一个小根堆
//    }
//    return 0;
//}
